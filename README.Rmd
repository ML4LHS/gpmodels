---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# wizard

## Windowed Summarization for Autoregressive Data

This package uses windowed summarization to convert time series data into a form that can be modeled by prediction models.

<!-- badges: start -->
<!-- badges: end -->

## Installation

You can install the GitHub version of wizard with:

```{r eval=FALSE}
remotes::install_github('ML4LHS/wizard')
```

## How to set up a wiz_frame()

Start by loading and package and defining your `wiz_frame()`. A `wiz_frame` is simply a list with the class `wiz_frame` and contains all the key information needed to describe both your fixed dataset (such as demographics, one row per patient) and your temporal dataset (one row per observation linked to a timestamp).

```{r eval=FALSE}
library(wizard)
```

```{r}
library(magrittr)
library(lubridate)

future::plan('multiprocess')

unlink(file.path(tempdir(), 'wiz_frame_dir', '*.*'))

wf = wiz_frame(fixed_data = sample_fixed_data,
               temporal_data = sample_temporal_data %>% dplyr::filter(id %in% 1:10),
               fixed_id = 'id',
               fixed_start = 'admit_time',
               fixed_end = 'dc_time',
               temporal_id = 'id',
               temporal_time = 'time',
               temporal_variable = 'variable',
               temporal_category = 'category',
               temporal_value = 'value',
               step = hours(6),
               output_folder = file.path(tempdir(), 'wiz_frame_dir'))
```

## Let's look at the automatically generated data dictionaries

```{r}
names(wf)

wf$step

wf$step_units

wf$fixed_data_dict

wf$temporal_data_dict
```

## Let's dummy-code the temporal categorical variables


```{r}
wf = wf %>% 
  wiz_categorical_to_numeric()
```


This affects only the temporal data and not the fixed data.

```{r}
wf$fixed_data_dict

wf$temporal_data_dict
```

## Let's add some predictors and outcomes

The default method writes output to the folder defined in your `wiz_frame`. When you write your output to file, you are allowed to chain together `add_predictors()` and `add_outcomes()` functions. This is possble because these functions invisibly return a `wiz_frame`.

If, however, you set `output_file` to `FALSE`, then your actual output is returned (rather than the `wiz_frame`) so you cannot chain functions.

```{r}
wf %>%           
  wiz_add_predictors(variable = 'cr', # Note: You can supply a vector of variables
                     lookback = hours(12), 
                     window = hours(6), 
                     stats = c(mean = mean,
                               min = min,
                               max = max,
                               median = median,
                               length = length)) %>% 
  wiz_add_predictors(category = 'med', # Note: category is always a regular expression 
                     lookback = days(7),
                     stats = c(sum = sum,
                               any = any),
                     impute = FALSE) %>% # Note: do *not* perform carry-forward imputation 
  wiz_add_outcomes(variable = 'cr',
                   lookahead = hours(24), 
                   stats = c(max = max))
```

## Let's combine our output into a single data frame

You can either provide `wiz_combine()` with a set of data frames or files separated by commas. Or, now you can provide a vector of file names using the `files` argument.

This resulting frame is essentially ready for modeling (using `tidymodels`, for example). Make sure to keep individual patients in the same fold if you divide this dataset into multiple folds.

```{r}
model_data = wiz_combine(wf, files = dir(file.path(tempdir(), 'wiz_frame_dir')))

dplyr::glimpse(model_data)
```


## Testing wiz_frame without writing output to files

If you want to simply test `wiz_frame`, you may prefer not to write your output to file. You can accomplish this by setting `output_file` to `FALSE`.

```{r}
wf %>% 
  wiz_add_predictors(variable = 'cr',
                     lookback = lubridate::hours(12), 
                     window = lubridate::hours(6), 
                     stats = c(mean = mean,
                               min = min,
                               max = max,
                               median = median,
                               length = length),
                     output_file = FALSE) %>% 
  dplyr::glimpse()
```

## You can supply a vector of variables

```{r}
wf %>% 
  wiz_add_predictors(variable = c('cr', 'cr_high_no'),
                     lookback = lubridate::weeks(1), 
                     stats = c(any = any),
                     output_file = FALSE) %>% 
  dplyr::glimpse()
```

## Let's benchmark the performance on our package

### Running in parallel

```{r message=FALSE}
benchmark_results = list()

future::plan('multiprocess')

benchmark_results[['multiprocess']] = 
  microbenchmark::microbenchmark(
    wf %>% 
      wiz_add_predictors(variable = 'cr',
                         lookback = lubridate::hours(12), 
                         window = lubridate::hours(6), 
                         stats = c(mean = mean,
                                   min = min,
                                   max = max,
                                   median = median,
                                   length = length),
                         output_file = FALSE),
    times = 1
  )
```

### Running in serial

```{r message=FALSE}
future::plan('sequential')

benchmark_results[['sequential']] = 
  microbenchmark::microbenchmark(
  wf %>% 
    wiz_add_predictors(variable = 'cr',
                       lookback = lubridate::hours(12), 
                       window = lubridate::hours(6), 
                       stats = c(mean = mean,
                                 min = min,
                                 max = max,
                                 median = median,
                                 length = length),
                       output_file = FALSE),
  times = 1
  )

```



### Implementation in the prior version (using `dplyr::group_modify()`)

```{r message=FALSE}
benchmark_results[['group_modify']] =
  microbenchmark::microbenchmark(
    wf %>% 
      wiz_add_predictors_group_modify(variable = 'cr',
                                      lookback = lubridate::hours(12), 
                                      window = lubridate::hours(6), 
                                      stats = c(mean = mean,
                                                min = min,
                                                max = max,
                                                median = median,
                                                length = length),
                                      output_file = FALSE),
    times = 1
  )
```

## Benchmark results

```{r}
benchmark_results
```

